<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Зонована карта доставки</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .toolbar { display: flex; gap: 8px; padding: 12px; border-bottom: 1px solid #eee; align-items: center; }
    .pill { flex: 1; border: 1px solid #ddd; border-radius: 999px; padding: 10px 14px; }
    .btn { border: 1px solid #0a7; border-radius: 10px; padding: 10px 14px; background: #0fa; cursor: pointer; }
    .btn:active { transform: translateY(1px); }
    .badge { padding: 6px 10px; border-radius: 999px; font-weight: 600; }
    .ok { background:#e8fff4; color:#116b3b; border:1px solid #b7f2d4; }
    .no { background:#fff1f0; color:#a11; border:1px solid #ffd1cf; }
    .warn { background:#fffbe6; color:#8a6d00; border:1px solid #ffe58f; }
    #map { width: 100%; height: 100%; }
    .legend { position:absolute; bottom:12px; left:12px; background: #fff; border:1px solid #eee; border-radius:12px; padding:10px 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); font-size: 14px; }
    .legend-row { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .swatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(0,0,.2) }
  </style>
</head>
<body>
  <div id="app">
    <div class="toolbar">
      <span class="badge ok">Старт: Львів</span>
      <input id="dest-input" class="pill" placeholder="Введіть місце призначення" />
      <button id="locate" class="btn">Моє місцезнаходження</button>
      <div id="status" class="badge warn">Очікую вибір…</div>
    </div>
    <div id="map"></div>
  </div>

  <div class="legend">
    <div class="legend-row"><div class="swatch" style="background:#a3d9a5"></div> ≤50 км — зелена зона</div>
    <div class="legend-row"><div class="swatch" style="background:#ffd59e"></div> 50–100 км — жовта зона</div>
    <div class="legend-row"><div class="swatch" style="background:#f3a5a5"></div> >100 км — червона зона</div>
  </div>

  <script>
    const BASE = { lat: 49.8397, lng: 24.0297 }; // Львів
    const DIST_THRESH = { green_km: 50, yellow_km: 100 };

    const CORRIDOR_REQUESTS = [
      { name: 'E40/M06 (Львів — Рівне)', origin: 'Львів, Україна', destination: 'Рівне, Україна', waypoints: ['Броди, Україна', 'Дубно, Україна'] },
      { name: 'H17 (Львів — Луцьк)', origin: 'Львів, Україна', destination: 'Луцьк, Україна', waypoints: ['Горохів, Україна'] },
      { name: 'P15 (Львів — Червоноград — Ковель)', origin: 'Львів, Україна', destination: 'Ковель, Україна', waypoints: ['Червоноград, Україна', 'Володимир, Україна'] },
      { name: 'H02 (Львів — Тернопіль)', origin: 'Львів, Україна', destination: 'Тернопіль, Україна', waypoints: [] }
    ];

    let map, directionsService, marker, builtCorridors = [];

    function initMap() {
      const bounds = new google.maps.LatLngBounds();
      // координати для охоплення тільки чотирьох областей
      bounds.extend({ lat: 50.75, lng: 22.0 }); // пн-зх
      bounds.extend({ lat: 49.0, lng: 27.0 }); // пд-сх

      map = new google.maps.Map(document.getElementById('map'), {
        center: BASE,
        zoom: 7,
        disableDefaultUI: true,
        restriction: {
          latLngBounds: bounds,
          strictBounds: true
        }
      });

      directionsService = new google.maps.DirectionsService();
      buildCorridors();

      const input = document.getElementById('dest-input');
      const autocomplete = new google.maps.places.Autocomplete(input, { types: ['(cities)'], componentRestrictions: { country: 'ua' } });
      autocomplete.addListener('place_changed', () => {
        const place = autocomplete.getPlace();
        if (!place.geometry) return;
        const dest = { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() };
        evaluateAgainstCorridors(dest, place.formatted_address || place.name);
        placeMarker(dest);
      });

      document.getElementById('locate').addEventListener('click', () => {
        if (!navigator.geolocation) return;
        navigator.geolocation.getCurrentPosition(pos => {
          const dest = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          evaluateAgainstCorridors(dest, 'Моє місцезнаходження');
          placeMarker(dest);
        });
      });
    }

    function placeMarker(destination) {
      if (!marker) marker = new google.maps.Marker({ map });
      marker.setPosition(destination);
    }

    async function buildCorridors() {
      builtCorridors = [];
      for (const req of CORRIDOR_REQUESTS) {
        const res = await directionsService.route({
          origin: req.origin,
          destination: req.destination,
          waypoints: (req.waypoints || []).map(w => ({ location: w })),
          travelMode: google.maps.TravelMode.DRIVING
        });
        builtCorridors.push({ name: req.name, path: res.routes[0].overview_path });
      }
    }

    function evaluateAgainstCorridors(latlng, label) {
      if (!builtCorridors.length) return;
      const pt = new google.maps.LatLng(latlng);
      let minMeters = Infinity, nearestCorr = null;
      for (const corr of builtCorridors) {
        const d = distanceToPolylineMeters(pt, corr.path);
        if (d < minMeters) { minMeters = d; nearestCorr = corr; }
      }
      const km = Math.round(minMeters / 1000);
      const status = document.getElementById('status');
      if (km <= DIST_THRESH.green_km) {
        status.className = 'badge ok';
        status.textContent = `${label}: ${km} км — ЗЕЛЕНА зона`;
      } else if (km <= DIST_THRESH.yellow_km) {
        status.className = 'badge warn';
        status.textContent = `${label}: ${km} км — ЖОВТА зона`;
      } else {
        status.className = 'badge no';
        status.textContent = `${label}: ${km} км — ЧЕРВОНА зона`;
      }
    }

    function distanceToPolylineMeters(point, pathLatLngs) {
      let min = Infinity;
      for (let i = 0; i < pathLatLngs.length - 1; i++) {
        const a = pathLatLngs[i];
        const b = pathLatLngs[i+1];
        const d = distancePointToSegmentMeters(point, a, b);
        if (d < min) min = d;
      }
      return min;
    }

    function distancePointToSegmentMeters(p, a, b) {
      const toXY = ll => ({ x: ll.lng(), y: Math.log(Math.tan((Math.PI/4) + (ll.lat()*Math.PI/180)/2)) });
      const P = toXY(p), A = toXY(a), B = toXY(b);
      const ABx = B.x - A.x, ABy = B.y - A.y;
      const APx = P.x - A.x, APy = P.y - A.y;
      const ab2 = ABx*ABx + ABy*ABy || 1e-12;
      let t = (APx*ABx + APy*ABy) / ab2; t = Math.max(0, Math.min(1, t));
      const proj = new google.maps.LatLng(
        (Math.atan(Math.sinh(A.y + ABy*t))*180/Math.PI),
        (A.x + ABx*t)
      );
      return google.maps.geometry.spherical.computeDistanceBetween(p, proj);
    }
  </script>

  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDFR9n0yr9SEPDWGyH1G_dDJBit7bxvy_Y&libraries=places,geometry&callback=initMap"></script>
</body>
</html>