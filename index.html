<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Зонована карта доставки</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    .toolbar { display: grid; gap: 8px; grid-template-columns: 1fr auto auto; padding: 12px; border-bottom: 1px solid #eee; }
    .pill { border: 1px solid #ddd; border-radius: 999px; padding: 10px 14px; }
    .btn { border: 1px solid #0a7; border-radius: 10px; padding: 10px 14px; background: #0fa; cursor: pointer; }
    .btn:active { transform: translateY(1px); }
    .badge { padding: 6px 10px; border-radius: 999px; font-weight: 600; }
    .ok { background:#e8fff4; color:#116b3b; border:1px solid #b7f2d4; }
    .no { background:#fff1f0; color:#a11; border:1px solid #ffd1cf; }
    .warn { background:#fffbe6; color:#8a6d00; border:1px solid #ffe58f; }
    #map { width: 100%; height: 100%; }
    .legend { position:absolute; bottom:12px; left:12px; background: #fff; border:1px solid #eee; border-radius:12px; padding:10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); }
    .legend-row { display:flex; align-items:center; gap:8px; margin:6px 0; }
    .swatch { width:16px; height:16px; border-radius:4px; border:1px solid rgba(0,0,0,.2) }
  </style>
</head>
<body>
  <div id="app">
    <div class="toolbar">
      <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
        <span class="badge ok" title="Початкова точка">Старт: Львів</span>
        <input id="dest-input" class="pill" placeholder="Введіть місце призначення (місто/селище)" />
      </div>
      <button id="locate" class="btn">Моє місцезнаходження</button>
      <div id="status" class="badge warn">Введіть місце призначення…</div>
    </div>
    <div id="map"></div>
  </div>

  <div class="legend" id="legend">
    <div class="legend-row"><div class="swatch" style="background:#a3d9a5"></div> До 50 км — зелена зона (безкоштовна доставка)</div>
    <div class="legend-row"><div class="swatch" style="background:#ffd59e"></div> 50–100 км — жовта зона (уточнювати)</div>
    <div class="legend-row"><div class="swatch" style="background:#f3a5a5"></div> >100 км — червона зона (безкоштовно не пропонувати)</div>
  </div>

  <script>
    const BASE = { lat: 49.8397, lng: 24.0297 }; // Львів
    const DIST_THRESH = { green_km: 50, yellow_km: 100 };

    const CORRIDOR_REQUESTS = [
      { name: 'E40/M06 (Львів — Рівне)', origin: 'Львів, Україна', destination: 'Рівне, Україна', waypoints: ['Броди, Україна', 'Дубно, Україна'] },
      { name: 'H17 (Львів — Луцьк)', origin: 'Львів, Україна', destination: 'Луцьк, Україна', waypoints: ['Горохів, Україна'] },
      { name: 'P15 (Львів — Червоноград — Ковель)', origin: 'Львів, Україна', destination: 'Ковель, Україна', waypoints: ['Червоноград, Україна', 'Володимир, Україна'] },
      { name: 'H02 (Львів — Тернопіль)', origin: 'Львів, Україна', destination: 'Тернопіль, Україна', waypoints: [] }
    ];

    let map, directionsService, marker;
    let builtCorridors = [];

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: BASE,
        zoom: 8,
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false,
        zoomControl: true,
        styles: [
          { featureType: 'poi', stylers: [{ visibility: 'off' }] },
          { featureType: 'transit', stylers: [{ visibility: 'off' }] },
          { featureType: 'road', elementType: 'labels.icon', stylers: [{ visibility: 'off' }] },
          { featureType: 'administrative', elementType: 'labels', stylers: [{ visibility: 'simplified' }] },
          { featureType: 'road', elementType: 'geometry', stylers: [{ lightness: 30 }] }
        ]
      });

      directionsService = new google.maps.DirectionsService();
      buildCorridors();

      const input = document.getElementById('dest-input');
      const autocomplete = new google.maps.places.Autocomplete(input, { types: ['(cities)'], componentRestrictions: { country: 'ua' } });
      autocomplete.addListener('place_changed', () => {
        const place = autocomplete.getPlace();
        if (!place.geometry) return;
        const dest = { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() };
        buildRoute(BASE, dest, place.formatted_address || place.name);
        evaluateAgainstCorridors(dest, place.formatted_address || place.name);
      });

      document.getElementById('locate').addEventListener('click', () => {
        if (!navigator.geolocation) return;
        navigator.geolocation.getCurrentPosition(pos => {
          const dest = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          buildRoute(BASE, dest, 'Моє місцезнаходження');
          evaluateAgainstCorridors(dest, 'Моє місцезнаходження');
        });
      });
    }

    function buildRoute(origin, destination, label) {
      // спрощений режим: без прокладання маршруту — лише маркер та центрування
      if (!marker) marker = new google.maps.Marker({ map });
      marker.setPosition(destination);
      map.panTo(destination);
      map.setZoom(9);
    }

    async function buildCorridors() {
      builtCorridors = [];
      const dir = new google.maps.DirectionsService();
      for (const req of CORRIDOR_REQUESTS) {
        const res = await dir.route({
          origin: req.origin,
          destination: req.destination,
          waypoints: (req.waypoints || []).map(w => ({ location: w })),
          travelMode: google.maps.TravelMode.DRIVING
        });
        const path = res.routes[0].overview_path;
        builtCorridors.push({ name: req.name, path });
        new google.maps.Polyline({ map, path, strokeColor: '#888', strokeOpacity: 0.6, strokeWeight: 2 });
      }
    }

    function evaluateAgainstCorridors(latlng, label) {
      if (!builtCorridors.length) {
        const s = document.getElementById('status');
        s.className = 'badge warn';
        s.textContent = 'Коридори ще не побудовані';
        return;
      }
      const pt = new google.maps.LatLng(latlng);
      let minMeters = Infinity, nearestCorr = null;
      for (const corr of builtCorridors) {
        const d = distanceToPolylineMeters(pt, corr.path);
        if (d < minMeters) { minMeters = d; nearestCorr = corr; }
      }
      const km = Math.round(minMeters / 1000);
      const status = document.getElementById('status');
      if (km <= DIST_THRESH.green_km) {
        status.className = 'badge ok';
        status.textContent = `${label}: ${km} км від траси (${nearestCorr?.name}) — ЗЕЛЕНА зона: можна пропонувати безкоштовну доставку.`;
      } else if (km <= DIST_THRESH.yellow_km) {
        status.className = 'badge warn';
        status.textContent = `${label}: ${km} км від траси (${nearestCorr?.name}) — ЖОВТА зона: уточнювати.`;
      } else {
        status.className = 'badge no';
        status.textContent = `${label}: ${km} км від траси (${nearestCorr?.name}) — ЧЕРВОНА зона: безкоштовна доставка не пропонується.`;
      }
    }

    function distanceToPolylineMeters(point, pathLatLngs) {
      let min = Infinity;
      for (let i = 0; i < pathLatLngs.length - 1; i++) {
        const a = pathLatLngs[i];
        const b = pathLatLngs[i+1];
        const d = distancePointToSegmentMeters(point, a, b);
        if (d < min) min = d;
      }
      return min;
    }

    function distancePointToSegmentMeters(p, a, b) {
      const toXY = ll => ({ x: ll.lng(), y: Math.log(Math.tan((Math.PI/4) + (ll.lat()*Math.PI/180)/2)) });
      const P = toXY(p), A = toXY(a), B = toXY(b);
      const ABx = B.x - A.x, ABy = B.y - A.y;
      const APx = P.x - A.x, APy = P.y - A.y;
      const ab2 = ABx*ABx + ABy*ABy || 1e-12;
      let t = (APx*ABx + APy*ABy) / ab2; t = Math.max(0, Math.min(1, t));
      const proj = new google.maps.LatLng(
        (Math.atan(Math.sinh(A.y + ABy*t))*180/Math.PI),
        (A.x + ABx*t)
      );
      return google.maps.geometry.spherical.computeDistanceBetween(p, proj);
    }
  </script>

  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDFR9n0yr9SEPDWGyH1G_dDJBit7bxvy_Y&libraries=places,geometry&callback=initMap"></script>
</body>
</html>
